---
title: "Descripción de las funciones de incertidumbre"
author: "María Benítez Moreno"
date: "2022-10-20"
output: 
  pdf_document:
    number_sections: yes
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

# ¿Qué hacen las funciones de incertidumbre?

En los siguientes apartados explicaremos un poco en que consiste cada criterio y  
para las funciones cuales son los datos que debemos meter y para que sirven, además 
de lo que muestra la salida.  

## Criterio de Wald o Pesimista

```{r}
criterio.Wald = function(tablaX,favorable=TRUE) {

  X = tablaX;
  if (favorable) {
    AltW = apply(X,MARGIN=1,min);
    ##AltW
    Wald = max(AltW);
    Alt_Wald = which.max.general(AltW);
    metodo = 'favorable';
  } else {
    AltW = apply(X,MARGIN=1,max);
    ##AltW
    Wald = min(AltW);
    Alt_Wald = which.min.general(AltW);
    metodo = 'desfavorable';
  }
  resultados = list();
  resultados$criterio = 'Wald';
  resultados$metodo = metodo;
  resultados$tablaX = tablaX;
  resultados$ValorAlternativas = AltW;
  resultados$ValorOptimo = Wald;
  resultados$AlternativaOptima = Alt_Wald;
  resultados$Recomendación = paste("Por lo tanto, la alternativa recomendada
                                   es la número", Alt_Wald);

  return(resultados);

  
}
```

## Criterio optimista

```{r}
criterio.Optimista = function(tablaX,favorable=TRUE) {

  X = tablaX;
  if (favorable) {
    AltM = apply(X,MARGIN=1,max);
    ##AltM
    Maximax = max(AltM);
    Alt_Maximax = which.max.general(AltM);
    metodo = 'favorable';
  } else {
    AltM = apply(X,MARGIN=1,min);
    ##AltM
    Maximax = min(AltM);
    Alt_Maximax = which.min.general(AltM);
    metodo = 'desfavorable';
  }
  resultados = list();
  resultados$criterio = 'Optimista';
  resultados$metodo = metodo;
  resultados$tablaX = tablaX;
  resultados$ValorAlternativas = AltM;
  resultados$ValorOptimo = Maximax;
  resultados$AlternativaOptima = Alt_Maximax;
  resultados$Recomendación = paste("Por lo tanto, la alternativa recomendada es la número", Alt_Maximax);
  
  return(resultados);


}
```

## Criterio Hurwicz

## Criterio Savage
esto es una prueba

## Criterio Laplace

El criterio de Laplace está basado en el principio de razón de insuficiente. Como a priori no existe ninguna razón para suponer que un estado puede presentarse antes que los demás podemos considerar que todos los estados tienen la misma probabilidad de ocurrencia.

Así que para un problema de decisión con _n_ posibles estados de la naturaleza asignamos _1/n_ a cada uno de estos estados. El criterio consiste en calcular la media de cada una de las filas de la matriz de valores numéricos y elegir la decisión que nos produzca mator media.

```{r}
criterio.Laplace = function(tablaX,favorable=TRUE) {

  X = tablaX;
  if (favorable) {
    AltL = apply(X,MARGIN=1,mean); #aplicamos la media a todos
    Laplace = max(AltL) # favorable, así que nos quedamos con el maximo
    Alt_Laplace = which.max.general(AltL) #nos quedamos con el maximo de todos
    metodo = 'favorable';
  } else { #para el caso desfavorable actuamos igual pero nos quedamos con los minimos.
    AltL = apply(X,MARGIN=1,mean);
    Laplace = min(AltL) # desfavorable
    Alt_Laplace = which.min.general(AltL)
    metodo = 'desfavorable';
  }
  resultados = list();
  resultados$criterio = 'Laplace';
  resultados$metodo = metodo;
  resultados$tablaX = tablaX;
  resultados$ValorAlternativas = AltL;
  resultados$ValorOptimo = Laplace;
  resultados$AlternativaOptima = Alt_Laplace;
  resultados$Recomendación = paste("Por lo tanto, la alternativa recomendada es la número", Alt_Laplace);

  return(resultados);

}
```

Mediante a función criterio.Laplace aplicamos este criterio a nuestro problema de decisión. Hemos añadido comentarios durante el código que explica lo que hace en cada momento.

Le hemos añadido a la función un texto que nos indica cual es la alternativa óptima.

## Criterio PuntoIdeal

Es un criterio de cierta forma geométrico, pues como su nombre lo indica, lo que hace es definir un punto ideal (en $\mathbb{R}^{c}$), siendo $c$ el número de criterios) que representa la alternativa ideal considerando el valor máximo de cada criterio observando todas las alternativas (en el caso de que sea favorable). Luego, se define la valoración de dicha alternativa como la distancia del punto en $\mathbb{R}^{c}$, cuyos elementos son las valoraciones para cada criterio de dicha alternativa y el punto ideal definido. Esta distancia puede definirse de varias formas, la que usa esta función es la distancia euclideana.

```{r}
criterio.PuntoIdeal = function(tablaX,favorable=TRUE) {

  # Recibe la tabla de alternativas y valoraciones para cada crietrio
  X = tablaX;
  
  # Si la matriz es de beneficios se busca el maximo
  if (favorable) {
    # Se define el vector MejoresPT como el vector que resulta 
    # de aplicar la funcion maximo a cada columna de la matriz (cada criterio),
    # por lo que resulta de longitud el numero de alternativas
    MejoresPT = apply(X,MARGIN=2,max); # favorable
    
    # Se define la variable AltPT como un vector de ceros
    # con longitud el numero de filas de la tabla (alternativas)
    AltPT = rep(0,dim(X)[1])
    
    # Se redefine cada elemento del vector AltPT como la distancia euclideana
    # entre la alternativa y el punto ideal
    # Es decir, que resulta un vector con la valoración para cada alternativa
    for (i in 1:dim(X)[1]) {
      AltPT[i] = distanciaEuclidea(MejoresPT,X[i,])
    }
    # Se le asigna el nombre de la alternativa a la columna de AltPT correspondiente
    names(AltPT) = rownames(tablaX)
    # La (o las) alternativa optimas sera aquella que tenga la menor distancia
    # por eso se define la variable PuntoIdeal
    PuntoIdeal = min(AltPT);
    # Con la funcion which.min.general definida previamente se almacena en la variable
    # Alt_PuntoIdeal el vector con la (o las) posicion de la alternativa almacenada en PuntoIdeal
    Alt_PuntoIdeal = which.min.general(AltPT);
    metodo = 'favorable';
  # Si no es de beneficios, sera de costos, es decir, que el punto ideal no sera el maximo
  # sino el minimo, por lo que se repite el proceso pero ahora tomando en minimo
  } else {
    MejoresPT = apply(X,MARGIN=2,min); # desfavorable
    AltPT = rep(0,dim(X)[1])
    names(AltPT) = rownames(tablaX)
    for (i in 1:dim(X)[1]) {
      AltPT[i] = distanciaEuclidea(MejoresPT,X[i,])
    }
    ##AltPT
    PuntoIdeal = min(AltPT);
    Alt_PuntoIdeal = which.min.general(AltPT);
    metodo = 'desfavorable';
  }
  # Se construye una lista que contiene distintas caracteristicas
  # del metodo empleado y el resultado para que devuelva al usar la funcion
  resultados = list();
  resultados$criterio = 'Punto Ideal';
  resultados$metodo = metodo;
  resultados$tablaX = tablaX;
  resultados$Mejores = MejoresPT;
  resultados$ValorAlternativas = AltPT;
  resultados$ValorOptimo = PuntoIdeal;
  resultados$AlternativaOptima = Alt_PuntoIdeal;
  resultados$Recomendación = paste("Por lo tanto, 
                                   la alternativa recomendada es la número", Alt_PuntoIdeal);


  return(resultados);

}
```
