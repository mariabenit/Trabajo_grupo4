---
title: "Descripción de las funciones de incertidumbre"
author: "María Benítez Moreno"
date: "2022-10-20"
output: 
  pdf_document:
    number_sections: yes
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE)
```

# ¿Qué hacen las funciones de incertidumbre?

En los siguientes apartados explicaremos un poco en que consiste cada criterio y  
para las funciones cuales son los datos que debemos meter y para que sirven, además 
de lo que muestra la salida.  

## Criterio de Wald o Pesimista

```{r}
criterio.Wald = function(tablaX,favorable=TRUE) {

  X = tablaX;
  if (favorable) {
    AltW = apply(X,MARGIN=1,min);
    ##AltW
    Wald = max(AltW);
    Alt_Wald = which.max.general(AltW);
    metodo = 'favorable';
  } else {
    AltW = apply(X,MARGIN=1,max);
    ##AltW
    Wald = min(AltW);
    Alt_Wald = which.min.general(AltW);
    metodo = 'desfavorable';
  }
  resultados = list();
  resultados$criterio = 'Wald';
  resultados$metodo = metodo;
  resultados$tablaX = tablaX;
  resultados$ValorAlternativas = AltW;
  resultados$ValorOptimo = Wald;
  resultados$AlternativaOptima = Alt_Wald;
  resultados$Recomendación = paste("Por lo tanto, la alternativa recomendada
                                   es la número", Alt_Wald);

  return(resultados);

  
}
```

## Criterio optimista

```{r}
criterio.Optimista = function(tablaX,favorable=TRUE) {

  X = tablaX;
  if (favorable) {
    AltM = apply(X,MARGIN=1,max);
    ##AltM
    Maximax = max(AltM);
    Alt_Maximax = which.max.general(AltM);
    metodo = 'favorable';
  } else {
    AltM = apply(X,MARGIN=1,min);
    ##AltM
    Maximax = min(AltM);
    Alt_Maximax = which.min.general(AltM);
    metodo = 'desfavorable';
  }
  resultados = list();
  resultados$criterio = 'Optimista';
  resultados$metodo = metodo;
  resultados$tablaX = tablaX;
  resultados$ValorAlternativas = AltM;
  resultados$ValorOptimo = Maximax;
  resultados$AlternativaOptima = Alt_Maximax;
  resultados$Recomendación = paste("Por lo tanto, la alternativa recomendada es la número", Alt_Maximax);
  
  return(resultados);


}
```

## Criterio Hurwicz

## Criterio Savage

Este criterio toma en consideración el coste de oportunidad por no preveer 
correctamente el estado de la naturaleza. Estos costes de oportunidad se evalúan 
para cada alternativa y cada estado, haciendo la diferencia entre lo mejor de
ese estado y lo que proporciona esa alternativa para ese estado, construyendo la 
llamada matriz de penalizaciones o costes de oportunidad. A esta matriz se le
aplica el criterio de minimizar el máximo arrepentimiento.

criterio.Savage = function(tablaX,favorable=TRUE) {
# hemos definido que por defecto tengamos favorable=TRUE, que indica que estamos trabajando con la matriz de beneficios
  X = tablaX; 
  if (favorable) { # si trabajamos con la matriz de beneficios se busca el máximo
    Mejores = apply(X,MARGIN=2,max); # a la tabla que vamos a estudiar le hace el máximo por columnas 
    temp1 = rep(Mejores,dim(X)[1]) # repetir los valores anteriores tantas veces como filas tenga la tabla 
    Mmejores = matrix(temp1,nrow=dim(X)[1],ncol=dim(X)[2],byrow=TRUE); # hacer una matriz con los valores anteriores que tenga el mismo número de filas y de columnas que tiene la tabla
    Pesos = abs(Mmejores-X); #calculamos los pesos hallando el valor absoluto de la diferencia entre la matriz anterior y la tabla  
    ## Ahora criterio Wald Minimax Pesimista (desfavorable)
    AltWS= apply(Pesos,MARGIN=1,max); # a los pesos le calculamos el máximo por filas
    Savage = min(AltWS); # de los valores anteriores nos quedamos con el valor mínimo
    Alt_Savage = which.min.general(AltWS); # posición en la que se encuentra el valor mínimo
    metodo = 'favorable'; # si favorable=TRUE, el método usado será "favorable"
  } else { # si trabajamos con la matriz de costos se busca el mínimo
    Mejores = apply(X,MARGIN=2,min); # a la tabla le hace el mínimo por columnas
    temp1 = rep(Mejores,dim(X)[1]) # repetir los valores anteriores tantas veces como filas tenga la tabla
    Mmejores = matrix(temp1,nrow=dim(X)[1],ncol=dim(X)[2],byrow=TRUE); # hacer una matriz con los valores anteriores que tenga el mismo número de filas y de columnas que tiene la tabla
    Pesos = abs(Mmejores-X); #calculamos los pesos hallando el valor absoluto de la diferencia entre la matriz anterior la tabla y 
    ## Ahora criterio Wald Minimax (desfavorable)
    AltWS= apply(Pesos,MARGIN=1,max); # a los pesos le calculamos el máximo por filas
    Savage = min(AltWS); # de los valores anteriores nos quedamos con el valor mínimo
    Alt_Savage = which.min.general(AltWS); # posición en la que se encuentra el valor mínimo
    metodo = 'desfavorable'; # si favorable=FALSE, el método usado será "desfavorable"
  }
  
  # los comandos siguientes son los resultados que queremos que nos muestre al compilar esta función
  resultados = list();
  resultados$criterio = 'Savage';
  resultados$metodo = metodo;
  resultados$tablaX = tablaX;
  resultados$Mejores = Mejores;
  resultados$Pesos = Pesos;
  resultados$ValorAlternativas = AltWS;
  resultados$ValorOptimo = Savage;
  resultados$AlternativaOptima = Alt_Savage;
  
  return(resultados);
  
  
}


Savage argumenta que después de tomar una decisión y de conocer el resultado, el 
decisor puede arrepentirse de haber seleccionado una alternativa concreta. 
Y por lo tanto, debe tratar de que ese arrepentimiento se reduzca al mínimo, es
decir, la alternativa seleccionada será aquella que minimice el arrepentimiento. 

Todo esto lo consguimos gracias a esta función y al compilarla, obtendremos los
siguientes resultados: el nombre del criterio usado (que en este caso será 
Savage), el método usado, la tabla con la que queremos trabajar, el máximo o el 
mínimo por columnas dependiendo del método y al cual hemos denominado "mejores", 
los pesos, el valor de las alternativas, el valor óptimo y la posición de la
alternativa óptima.

## Criterio Laplace

El criterio de Laplace está basado en el principio de razón de insuficiente. Como a priori no existe ninguna razón para suponer que un estado puede presentarse antes que los demás podemos considerar que todos los estados tienen la misma probabilidad de ocurrencia.

Así que para un problema de decisión con _n_ posibles estados de la naturaleza asignamos _1/n_ a cada uno de estos estados. El criterio consiste en calcular la media de cada una de las filas de la matriz de valores numéricos y elegir la decisión que nos produzca mator media.

```{r}
criterio.Laplace = function(tablaX,favorable=TRUE) {

  X = tablaX;
  if (favorable) {
    AltL = apply(X,MARGIN=1,mean); #aplicamos la media a todos
    Laplace = max(AltL) # favorable, así que nos quedamos con el maximo
    Alt_Laplace = which.max.general(AltL) #nos quedamos con el maximo de todos
    metodo = 'favorable';
  } else { #para el caso desfavorable actuamos igual pero nos quedamos con los minimos.
    AltL = apply(X,MARGIN=1,mean);
    Laplace = min(AltL) # desfavorable
    Alt_Laplace = which.min.general(AltL)
    metodo = 'desfavorable';
  }
  resultados = list();
  resultados$criterio = 'Laplace';
  resultados$metodo = metodo;
  resultados$tablaX = tablaX;
  resultados$ValorAlternativas = AltL;
  resultados$ValorOptimo = Laplace;
  resultados$AlternativaOptima = Alt_Laplace;
  resultados$Recomendación = paste("Por lo tanto, la alternativa recomendada es la número", Alt_Laplace);

  return(resultados);

}
```

Mediante a función criterio.Laplace aplicamos este criterio a nuestro problema de decisión. Hemos añadido comentarios durante el código que explica lo que hace en cada momento.

Le hemos añadido a la función un texto que nos indica cual es la alternativa óptima.

## Criterio PuntoIdeal

Es un criterio de cierta forma geométrico, pues como su nombre lo indica, lo que hace es definir un punto ideal (en $\mathbb{R}^{c}$), siendo $c$ el número de criterios) que representa la alternativa ideal considerando el valor máximo de cada criterio observando todas las alternativas (en el caso de que sea favorable). Luego, se define la valoración de dicha alternativa como la distancia del punto en $\mathbb{R}^{c}$, cuyos elementos son las valoraciones para cada criterio de dicha alternativa y el punto ideal definido. Esta distancia puede definirse de varias formas, la que usa esta función es la distancia euclideana.

```{r}
criterio.PuntoIdeal = function(tablaX,favorable=TRUE) {

  # Recibe la tabla de alternativas y valoraciones para cada crietrio
  X = tablaX;
  
  # Si la matriz es de beneficios se busca el maximo
  if (favorable) {
    # Se define el vector MejoresPT como el vector que resulta 
    # de aplicar la funcion maximo a cada columna de la matriz (cada criterio),
    # por lo que resulta de longitud el numero de alternativas
    MejoresPT = apply(X,MARGIN=2,max); # favorable
    
    # Se define la variable AltPT como un vector de ceros
    # con longitud el numero de filas de la tabla (alternativas)
    AltPT = rep(0,dim(X)[1])
    
    # Se redefine cada elemento del vector AltPT como la distancia euclideana
    # entre la alternativa y el punto ideal
    # Es decir, que resulta un vector con la valoración para cada alternativa
    for (i in 1:dim(X)[1]) {
      AltPT[i] = distanciaEuclidea(MejoresPT,X[i,])
    }
    # Se le asigna el nombre de la alternativa a la columna de AltPT correspondiente
    names(AltPT) = rownames(tablaX)
    # La (o las) alternativa optimas sera aquella que tenga la menor distancia
    # por eso se define la variable PuntoIdeal
    PuntoIdeal = min(AltPT);
    # Con la funcion which.min.general definida previamente se almacena en la variable
    # Alt_PuntoIdeal el vector con la (o las) posicion de la alternativa almacenada en PuntoIdeal
    Alt_PuntoIdeal = which.min.general(AltPT);
    metodo = 'favorable';
  # Si no es de beneficios, sera de costos, es decir, que el punto ideal no sera el maximo
  # sino el minimo, por lo que se repite el proceso pero ahora tomando en minimo
  } else {
    MejoresPT = apply(X,MARGIN=2,min); # desfavorable
    AltPT = rep(0,dim(X)[1])
    names(AltPT) = rownames(tablaX)
    for (i in 1:dim(X)[1]) {
      AltPT[i] = distanciaEuclidea(MejoresPT,X[i,])
    }
    ##AltPT
    PuntoIdeal = min(AltPT);
    Alt_PuntoIdeal = which.min.general(AltPT);
    metodo = 'desfavorable';
  }
  # Se construye una lista que contiene distintas caracteristicas
  # del metodo empleado y el resultado para que devuelva al usar la funcion
  resultados = list();
  resultados$criterio = 'Punto Ideal';
  resultados$metodo = metodo;
  resultados$tablaX = tablaX;
  resultados$Mejores = MejoresPT;
  resultados$ValorAlternativas = AltPT;
  resultados$ValorOptimo = PuntoIdeal;
  resultados$AlternativaOptima = Alt_PuntoIdeal;
  resultados$Recomendación = paste("Por lo tanto, 
                                   la alternativa recomendada es la número", Alt_PuntoIdeal);


  return(resultados);

}
```
